## 回流（Reflow）与重绘（Repaint）

回流：对DOM的修改引发了DOM几何尺寸的变化

重绘：对DOM的修改导致了样式的变化、但并未影响其几何属性



### *哪些实际操作会导致回流与重绘

要避免回流与重绘的发生，最直接的做法是避免掉可能会引发回流与重绘的DOM操作——掐灭导火索

**重绘的“导火索”**：

不触发回流，但又触发了样式改变的DOM操作。（如背景色、文字色、visibility等）

**回流的“导火索”**：

* 最“贵“的操作：改变DOM元素的几何属性

  ”牵一发而动全身“，导致空间布局发生变化——当一个DOM元素的几何属性发生变化时，所有和它相关的节点（如父子、兄弟）的几何属性都需要进行重新计算。——巨大的计算量

  常见几何属性：width、height、padding、margin、left、top、border等。

* ”价格适中“的操作：改变DOM树的结构

  主要是节点的增减、移动等操作。

  浏览器引擎布局的过程，顺序可类比于树的前序遍历——从上到下、从左到右。这个过程中，通常不会影响当前元素前面已经遍历过的元素。

* 最容易被忽略的操作：获取一些特定属性的值——即时性

  比如：offsetTop、offsetLeft、offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight等

  这些属性的值有一个共性，就是需要通过***即时计算***得到。浏览器为了获取这些值，也会进行回流。

  此外，调用getComputedStyle方法，或者IE里的currentStyle，也会触发回流。也是为求一个”即时性“和”准确性“。



### *如何规避回流与重绘

尽量规避使用。不得不使用的时候，更聪明地使用

* 将”导火索“缓存起来，避免频繁改动

  🌰：通过多次计算得到一个元素的布局位置

  如需要获取多次”敏感属性“，可以将其以JS变量的形式缓存起来，待计算完毕提交给浏览器发出重计算请求。

* 避免逐条改变样式，使用类名去合并样式

  每次单独操作，都去触发一次渲染树更改，从而导致相应的回流与重绘过程；（Event Loop）

  合并之后等于将所有的更改一次性发出，用一个style请求解决掉了。

* 将DOM”离线“

  回流和重绘，都是在”该元素位于页面上“的前提下回发生的。一但给元素设置`display: none;`，将其从页面上拿掉，后续操作将无法触发回流与重绘——这就叫做DOM离线化

  一但操作频繁，效果比较好。



### *Flush队列：浏览器没有那么简单

浏览器自己缓存了一个flush队列，把我们触发的回流与重绘任务都塞进去，待到队列里的任务多起来、或者达到了一定的时间间隔（16ms？）、或者”不得已“的时候，再将这些个任务一口气出队。

”不得已“的时候：”即时性“属性



### *小结

并不是所有的浏览器都是聪明的。=》良好的编码习惯、从根源上解决问题



####补充

《高性能JavaScript》

联系Event Loop

css3动画（transform、opacity、filters）不会引起回流重绘？？可以直接获得硬件加速。translate3D会开启GPU加速

Js动画（可操作性） Vs CSS动画（性能）

position: absolute / fixed; 的元素，对其进行几何尺寸的改变。（需要回流的元素范围变小了，只影响自身和子节点）



设置不可见：

display: none; （改变元素占位）

visibility: hidden;

opacity: 0;

color: transparent;   background: transparent;